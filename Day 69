437. Path Sum III

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> map = new HashMap<>();
        map.put(0L, 1);
        return dfs(root, 0L, targetSum, map);
    }

    private int dfs(TreeNode node, long currSum, int target, Map<Long, Integer> map) {
        if (node == null) return 0;
        currSum += node.val;
        int count = map.getOrDefault(currSum - target, 0);
        map.put(currSum, map.getOrDefault(currSum, 0) + 1);
        count += dfs(node.left, currSum, target, map);
        count += dfs(node.right, currSum, target, map);
        map.put(currSum, map.get(currSum) - 1);
        return count;
    }
}


2049. Count Nodes With the Highest Score

class Solution {
    private List<List<Integer>> tree;
    private int n;
    private long maxScore = 0;
    private int count = 0;

    public int countHighestScoreNodes(int[] parents) {
        n = parents.length;
        tree = new ArrayList<>();
        for (int i = 0; i < n; i++) tree.add(new ArrayList<>());
        for (int i = 1; i < n; i++) tree.get(parents[i]).add(i);
        dfs(0);
        return count;
    }

    private int dfs(int node) {
        long score = 1;
        int total = 1;
        for (int child : tree.get(node)) {
            int subSize = dfs(child);
            score *= subSize;
            total += subSize;
        }
        int rest = n - total;
        if (rest > 0) score *= rest;
        if (score > maxScore) {
            maxScore = score;
            count = 1;
        } else if (score == maxScore) {
            count++;
        }
        return total;
    }
}


2583. Kth Largest Sum in a Binary Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public long kthLargestLevelSum(TreeNode root, int k) {
        if (root == null) return -1;
        
        Queue<TreeNode> queue = new LinkedList<>();
        List<Long> levelSums = new ArrayList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            long sum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                sum += node.val;

                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            levelSums.add(sum);
        }

        Collections.sort(levelSums, Collections.reverseOrder());

        return (k <= levelSums.size()) ? levelSums.get(k - 1) : -1;
    }
}

