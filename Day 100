1964. Find the Longest Valid Obstacle Course at Each Position


class Solution {
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int n = obstacles.length;
        int[] arr = new int[n + 1];
        int right = 0;
        int[] ans = new int[n];
        for(int i = 0; i < n; i++) {
            int height = obstacles[i];
            int index = index = binarySearch(arr, right, height);
            if(index == right) right++;
            arr[index] = height;
            ans[i] = index + 1;
        }
        return ans;
    }
    private int binarySearch(int[] arr, int right, int target) {
        int left = 0;
        while(left < right) {
            int mid = (left + right) >> 1;
            if(arr[mid] > target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
}

2424. Longest Uploaded Prefix


class LUPrefix {
    private boolean[] uploaded;
    private int longestPrefix;
    
    public LUPrefix(int n) {
        uploaded = new boolean[n + 2]; 
        longestPrefix = 0;
    }
    public void upload(int video) {
        uploaded[video] = true;
        
        while (uploaded[longestPrefix + 1]) {
            longestPrefix++;
        }
    }
    public int longest() {
        return longestPrefix;
    }
}


/**
 * Your LUPrefix object will be instantiated and called as such:
 * LUPrefix obj = new LUPrefix(n);
 * obj.upload(video);
 * int param_2 = obj.longest();
 */

2250. Count Number of Rectangles Containing Each Point


class Solution {
    public int[] countRectangles(int[][] rectangles, int[][] points) {
        List<Integer>[] map = new ArrayList[101];
        for (int i = 1; i <= 100; i++) {
            map[i] = new ArrayList<>();
        }   
        for (int[] rect : rectangles) {
            int l = rect[0];
            int h = rect[1];
            map[h].add(l);
        } 
        for (int h = 1; h <= 100; h++) {
            Collections.sort(map[h]);
        }
        int n = points.length;
        int[] result = new int[n];
        
        for (int i = 0; i < n; i++) {
            int x = points[i][0];
            int y = points[i][1];
            int count = 0;
            
            for (int h = y; h <= 100; h++) {
                List<Integer> list = map[h];
                int index = lowerBound(list, x);
                count += list.size() - index;
            }
            result[i] = count;
        }
        
        return result;
    }
    
    private int lowerBound(List<Integer> list, int x) {
        int left = 0, right = list.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid) >= x) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
